package com.drguildo.tecs.jack

// Robustness is sacrificed for simplicity (to some extent).

import scala.collection.mutable.ListBuffer

import TokenType._

/**
 * Effects the actual compilation output. Gets its input from a JackTokenizer
 * and emits its parsed structure into an output file/stream. The output is
 * generated by a series of compilexxx() routines, one for every syntactic
 * element xxx of the Jack grammar. The contract between these routines is
 * that each compilexxx() routine should read the syntactic construct xxx from
 * the input, advance() the tokenizer exactly beyond xxx, and output the
 * parsing of xxx. Thus, compilexxx()may only be called if indeed xxx is the
 * next syntactic element of the input.
 *
 * In the first version of the compiler, described in Chapter 10, this module
 * emits a structured printout of the code, wrapped in XML tags. In the final
 * version of the compiler, described in Chapter 11, this module generates
 * executable VM code. In both cases, the parsing logic and module API are
 * exactly the same.
 */
class CompilationEngine(tokenizer: JackTokenizer) {
  val output = new ListBuffer[String]()

  /* 'xxx': Quoted boldface is used for tokens that appear verbatim
            ("terminals");
     xxx: Regular typeface is used for names of language constructs
          ("non-terminals");
     ( ): Parentheses are used for grouping of language constructs;
     x | y: Indicates that either x or y can appear;
     x?: Indicates that x appears 0 or 1 times;
     x*: Indicates that x appears 0 or more times. */

  /* Lexical elements: The Jack language includes five types of terminal
     elements (tokens):

     keyword: 'class' | 'constructor' | 'function' | 'method' | 'field' |
              'static' | 'var' | 'int' | 'char' | 'boolean' | 'void' | 'true' |
              'false' | 'null' | 'this' | 'let' | 'do' | 'if' | 'else' |
              'while' | 'return'
     symbol: '{' | '}' | '(' | ')' | '[' | ']' | '. ' | ', ' | '; ' | '+' |
             '-' | '*' | '/' | '&' | '|' | '<' | '>' | '=' |  '~'
     integerConstant: A decimal number in the range 0 .. 32767.
     stringConstant: '"' A sequence of Unicode characters not including double
                         quote or newline '"'
     identifier: A sequence of letters, digits, and underscore ( '_' ) not
                 starting with a digit. */

  /* Program structure: A Jack program is a collection of classes, each
     appearing in a separate file. The compilation unit is a class. A class is
     a sequence of tokens structured according to the following context free
     syntax: */
  compileClass()

  def compileClass() {
    // class: 'class' className '{' classVarDec* subroutineDec* '}'
    // className: identifier
    output.append("<class>")

    checkNextToken(("class", KEYWORD))
    output.append("<keyword> class </keyword>")

    compileIdentifier()

    checkNextToken(("{", SYMBOL))
    output.append("<symbol> { </symbol>")

    var t = tokenizer.nextToken()
    tokenizer.rewind()
    while (t !=("}", SYMBOL)) {
      t match {
        case ("static", KEYWORD) => compileClassVarDec()
        case ("field", KEYWORD) => compileClassVarDec()
        case ("constructor", KEYWORD) => compileSubroutine()
        case ("function", KEYWORD) => compileSubroutine()
        case ("method", KEYWORD) => compileSubroutine()
        case _ => throw new Exception("Not a classVarDec, subroutineDec or '}'.")
      }
      t = tokenizer.nextToken()
      tokenizer.rewind()
    }

    output.append("<symbol> } </symbol>")

    output.append("</class>")
  }

  def compileClassVarDec() {
    // classVarDec: ('static' | 'field' ) type varName (',' varName)*  ';'
    output.append("<classVarDec>")

    if (isNextToken(("static", KEYWORD)) || isNextToken("field", KEYWORD)) {
      output.append("<keyword> %s </keyword>".format(tokenizer.nextToken()._1))
    }

    compileType(false)

    compileIdentifier()

    while (isNextToken((",", SYMBOL))) {
      tokenizer.nextToken()
      output.append("<symbol> , </symbol>")

      compileIdentifier()
    }

    checkNextToken((";", SYMBOL))
    output.append("<symbol> ; </symbol>")

    output.append("</classVarDec>")
  }

  def compileSubroutine() {
    // subroutineDec: ('constructor' | 'function' | 'method')  ('void' | type)
    //                subroutineName '(' parameterList ')' subroutineBody
    // subroutineName: identifier
    output.append("<subroutineDec>")

    var t = tokenizer.nextToken()
    checkToken(t, List(("constructor", KEYWORD), ("function", KEYWORD), ("method", KEYWORD)))
    output.append("<keyword> %s </keyword>".format(t._1))

    compileType(true)

    compileIdentifier()

    checkNextToken(("(", SYMBOL))
    output.append("<symbol> ( </symbol>")

    compileParameterList()

    checkNextToken((")", SYMBOL))
    output.append("<symbol> ) </symbol>")

    compileSubroutineBody()

    output.append("</subroutineDec>")
  }

  def compileParameterList() {
    // parameterList: ((type varName) (',' type varName)*)?
    // varName: identifier
    output.append("<parameterList>")

    while (!isNextToken((")", SYMBOL))) {
      compileType(false)

      compileIdentifier()

      var t = tokenizer.nextToken()
      if (t == (",", SYMBOL)) {
        output.append("<symbol> , </symbol>")
      } else {
        checkToken(t, (")", SYMBOL))
        tokenizer.rewind()
      }
    }

    output.append("</parameterList>")
  }

  def compileSubroutineBody() {
    // subroutineBody: '{' varDec* statements '}'
    output.append("<subroutineBody>")

    checkNextToken(("{", SYMBOL))
    output.append("<symbol> { </symbol>")

    while (isNextToken(("var", KEYWORD))) {
      compileVarDec()
    }

    compileStatements()

    checkNextToken(("}", SYMBOL))
    output.append("<symbol> } </symbol>")

    output.append("</subroutineBody>")
  }

  def compileVarDec() {
    // varDec: 'var' type varName (',' varName)* ';'
    // varName: identifier
    output.append("<varDec>")

    checkNextToken(("var", KEYWORD))
    output.append("<keyword> var </keyword>")

    compileType(false)

    compileIdentifier()

    while (!isNextToken((";", SYMBOL))) {
      checkNextToken((",", SYMBOL))
      output.append("<symbol> , </symbol>")

      compileIdentifier()
    }

    checkNextToken((";", SYMBOL))
    output.append("<symbol> ; </symbol>")

    output.append("</varDec>")
  }

  def compileStatements() {
    // statement: letStatement | ifStatement | whileStatement | doStatement |
    // returnStatement
    output.append("<statements>")

    var t = tokenizer.nextToken()
    tokenizer.rewind()
    while (!(t == ("}", SYMBOL))) {
      t match {
        case ("let", KEYWORD) => compileLet()
        case ("if", KEYWORD) => compileIf()
        case ("while", KEYWORD) => compileWhile()
        case ("do", KEYWORD) => compileDo()
        case ("return", KEYWORD) => compileReturn()
        case _ => throw new Exception(t + " is not a statement.")
      }
      t = tokenizer.nextToken()
      tokenizer.rewind()
    }

    output.append("</statements>")
  }

  def compileLet() {
    // letStatement: 'let'  varName ('[' expression ']')? '=' expression ';'
    output.append("<letStatement>")

    checkNextToken(("let", KEYWORD))
    output.append("<keyword> let </keyword>")

    compileIdentifier()

    if (isNextToken("[", SYMBOL)) {
      tokenizer.nextToken()
      output.append("<symbol> [ </symbol>")

      compileExpression()

      checkNextToken(("]", SYMBOL))
      output.append("<symbol> ] </symbol>")
    }

    checkNextToken(("=", SYMBOL))

    compileExpression()

    checkNextToken((";", SYMBOL))
    output.append("<symbol> ; </symbol>")

    output.append("</letStatement>")
  }

  def compileIf() {
    // ifStatement: 'if' '(' expression ')' '{' statements '}'
    //              ( 'else' '{' statements '}' )?
    output.append("<ifStatement>")

    checkNextToken(("if", KEYWORD))
    output.append("<keyword> if </keyword>")

    checkNextToken(("(", SYMBOL))
    output.append("<symbol> ( </symbol>")

    compileExpression()

    checkNextToken((")", SYMBOL))
    output.append("<symbol> ) </symbol>")

    checkNextToken(("{", SYMBOL))
    output.append("<symbol> { </symbol>")

    compileStatements()

    checkNextToken(("}", SYMBOL))
    output.append("<symbol> } </symbol>")

    if (isNextToken(("else", KEYWORD))) {
      tokenizer.nextToken()
      output.append("<keyword> else </keyword>")

      checkNextToken(("{", SYMBOL))
      output.append("<symbol> { </symbol>")

      compileStatements()

      checkNextToken(("}", SYMBOL))
      output.append("<symbol> } </symbol>")
    }

    output.append("</ifStatement>")
  }

  def compileWhile() {
    // whileStatement: 'while' '(' expression ')' '{' statements '}'
    output.append("<whileStatement>")

    checkNextToken(("while", KEYWORD))
    output.append("<keyword> while </keyword>")

    checkNextToken(("(", SYMBOL))
    output.append("<symbol> ( </symbol>")

    compileExpression()

    checkNextToken((")", SYMBOL))
    output.append("<symbol> ) </symbol>")

    checkNextToken(("{", SYMBOL))
    output.append("<symbol> { </symbol>")

    compileStatements()

    checkNextToken(("}", SYMBOL))
    output.append("<symbol> } </symbol>")

    output.append("</whileStatement>")
  }

  def compileDo() {
    // doStatement: 'do' subroutineCall ';'
    // subroutineCall: subroutineName '(' expressionList ')' |
    //                 ( className | varName) '.' subroutineName
    //                                            '(' expressionList ')'

    output.append("<doStatement>")

    checkNextToken(("do", KEYWORD))
    output.append("<keyword> do </keyword>")

    compileIdentifier()

    if (isNextToken((".", SYMBOL))) {
      tokenizer.nextToken()
      output.append("<symbol> . </symbol>")

      compileIdentifier()
    }

    checkNextToken(("(", SYMBOL))
    output.append("<symbol> ( </symbol>")

    compileExpressionList()

    checkNextToken((")", SYMBOL))
    output.append("<symbol> ) </symbol>")

    checkNextToken((";", SYMBOL))
    output.append("<symbol> ; </symbol>")

    output.append("</doStatement>")
  }

  def compileReturn() {
    // returnStatement: 'return' expression? ';'
    output.append("<returnStatement>")

    checkNextToken(("return", KEYWORD))
    output.append("<keyword> return </keyword>")

    if (!isNextToken((";", SYMBOL))) {
      compileExpression()
    }

    checkNextToken((";", SYMBOL))
    output.append("<symbol> ; </symbol>")

    output.append("</returnStatement>")
  }

  def compileExpressionList() {
    // expressionList: (expression (',' expression)* )?
    output.append("<expressionList>")

    while (!isNextToken((")", SYMBOL))) {
      if (isNextToken(",", SYMBOL)) {
        tokenizer.nextToken()
        output.append("<symbol> , </symbol>")
      }

      compileExpression()
    }

    output.append("</expressionList>")
  }

  def compileExpression() {
    // expression: term (op term)*
    // op: '+' | '-' | '*' | '/' | '&' | '|' | '<' | '>' | '='
    val ops = List("+", "-", "*", "/", "&", ",", "<", ">", "=")

    output.append("<expression>")

    compileTerm()

    var nt = tokenizer.nextToken()
    while (ops.contains(nt._1)) {
      output.append("<symbol> %s </symbol>".format(nt._1))

      compileTerm()

      nt = tokenizer.nextToken()
    }
    tokenizer.rewind()

    output.append("</expression>")
  }

  def compileTerm() {
    // term: integerConstant | stringConstant | keywordConstant | varName |
    //       varName '[' expression ']' | subroutineCall  | '(' expression ')' |
    //       unaryOp term
    // unaryOp: '-' | '~'
    output.append("<term>")

    // In the case of unaryOp, can we recursively call compileTerm, and change
    // this to a val?
    var nt = tokenizer.nextToken()

    if ((nt == ("-", SYMBOL)) || (nt == ("~", SYMBOL))) {
      output.append("<symbol> %s </symbol>".format(nt._1))
      nt = tokenizer.nextToken()
    }

    if (nt == ("(", SYMBOL)) {
      output.append("<symbol> ( </symbol>")

      compileExpression()

      checkNextToken((")", SYMBOL))
      output.append("<symbol> ) </symbol>")

      output.append("</term>")

      return
    }

    if (nt._2 == IDENTIFIER) {
      tokenizer.rewind()

      compileIdentifier()

      if (isNextToken("[", SYMBOL)) {
        tokenizer.nextToken()
        output.append("<symbol> [ </symbol>")

        compileExpression()

        checkNextToken(("]", SYMBOL))
        output.append("<symbol> ] </symbol>")

        output.append("</term>")

        return
      }

      if (isNextToken((".", SYMBOL))) {
        tokenizer.nextToken()
        output.append("<symbol> . </symbol>")

        compileIdentifier()
      }

      if (isNextToken(("(", SYMBOL))) {
        tokenizer.nextToken()
        output.append("<symbol> ( </symbol>")

        compileExpressionList()

        checkNextToken((")", SYMBOL))
        output.append("<symbol> ) </symbol>")
      }

      output.append("</term>")

      return
    }

    nt._2 match {
      case INT_CONST => output.append("<integerConstant> %s </integerConstant>".format(nt._2))
      case STRING_CONST => output.append("<stringConstant> %s </stringConstant>".format(nt._2))
      case KEYWORD => output.append("<keywordConstant> %s </keywordConstant>".format(nt._2))
      case _ => throw new Exception("Something bad happened.")
    }

    output.append("</term>")
  }

  // Helper functions

  def compileType(voidable: Boolean) {
    // type: 'int' | 'char' | 'boolean' | className
    def ifVoidable() {
      if (voidable) {
        output.append("<keyword> void </keyword>")
      } else {
        throw new Exception("void is not a valid type in this context.")
      }
    }

    val t = tokenizer.nextToken()
    t match {
      case ("void", KEYWORD) => ifVoidable()
      case ("int", KEYWORD) => output.append("<keyword> int </keyword>")
      case ("char", KEYWORD) => output.append("<keyword> char </keyword>")
      case ("boolean", KEYWORD) => output.append("<keyword> boolean </keyword>")
      case (_, IDENTIFIER) => output.append("<identifier> %s </identifier>".format(t._1))
      case _ => throw new Exception("Not a valid type.")
    }
  }

  def compileIdentifier() {
    val t = tokenizer.nextToken()
    checkToken(t, IDENTIFIER)
    if (t._1(0).isDigit) {
      throw new Exception("First character of identifier cannot be a digit.")
    }
    if (t._1.exists(c => !(c.isLetterOrDigit || c == '_'))) {
      throw new Exception("Identifiers can contain only letters, digits and underscores.")
    }
    output.append("<identifier> %s </identifier>".format(t._1))
  }

  //def isToken(t1: Token, t2: Token): Boolean = t1 == t2

  def isToken(t: Token, ss: List[Token]): Boolean = ss.exists(t == _)

  //def isTokenType(t: Token, tt: TokenType): Boolean = t._2 == tt

  def isNextToken(t: Token): Boolean = {
    val nt = tokenizer.nextToken()
    tokenizer.rewind()

    t == nt
  }

  def checkToken(t1: Token, t2: Token) {
    if (!(t1 == t2)) {
      throw new Exception("Expected: %s, Got: %s".format(t2, t1))
    }
  }

  def checkToken(t: Token, tt: TokenType) {
    if (t._2 != tt) {
      throw new Exception("Expected: %s, Got: %s".format(tt, t._2))
    }
  }

  def checkToken(t: Token, ss: List[Token]) {
    if (!isToken(t, ss)) {
      throw new Exception("Expected: %s, Got: %s".format(ss, t))
    }
  }

  def checkNextToken(t: Token) {
    checkToken(tokenizer.nextToken(), t)
  }
}
